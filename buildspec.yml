version: 0.2

env:
  variables:
    TERRAFORM_VERSION: "1.5.5"

phases:
  install:
    commands:
      # Nenhuma alteração necessária aqui. Sua fase de instalação está perfeita.
      - |
        echo "Instalando o Terraform ${TERRAFORM_VERSION}..."
        ARCH=$(uname -m | sed -e 's/aarch64/arm64/' -e 's/x86_64/amd64/')
        wget -q "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_${ARCH}.zip"
        unzip terraform_*.zip
        mkdir -p $HOME/bin
        mv terraform $HOME/bin/
        export PATH="$HOME/bin:$PATH"
        echo "Verificando a instalação do Terraform..."
        terraform --version

  pre_build:
    commands:
      # Seu bloco de download do S3 permanece como está.
      - |
        echo "Construindo o caminho do S3 para o arquivo main.tf..."
        TF_CODE_PATH="s3://${AWS_S3_BUCKET_TARGET_NAME_0}/states/${STATE_NAME}/main.tf"
        
        echo "Baixando o arquivo main.tf de: ${TF_CODE_PATH}"
        aws s3 cp "${TF_CODE_PATH}" .
        
        echo "Arquivo main.tf baixado com sucesso."
        echo "--------------------------------------------------"
        echo "ESTRUTURA DE ARQUIVOS ANTES DO AJUSTE (VISUALIZAÇÃO):"
        ls -laR
        echo "--------------------------------------------------"

      # --- INÍCIO DA NOVA FUNCIONALIDADE: ASSUMIR ROLE DINÂMICA ---
      # Este bloco é inserido aqui para assumir a role antes de inicializar o Terraform.
      - |
        echo "=================================================="
        echo "ASSUMINDO A ROLE DINÂMICA..."
        
        if [ -z "${DYNAMIC_ASSUMABLE_ROLE_ARN}" ]; then
          echo "ERRO: A variável DYNAMIC_ASSUMABLE_ROLE_ARN não foi definida. Abortando."
          exit 1
        fi
        
        echo "Role a ser assumida: ${DYNAMIC_ASSUMABLE_ROLE_ARN}"
        
        # Usa o AWS CLI para assumir a role e armazena as credenciais temporárias em um JSON.
        TEMP_ROLE_JSON=$(aws sts assume-role --role-arn "${DYNAMIC_ASSUMABLE_ROLE_ARN}" --role-session-name "CodeBuild-Terraform-Session")
        
        # Verifica se o comando falhou.
        if [ $? -ne 0 ]; then
          echo "ERRO: Falha ao assumir a role. Verifique as permissões sts:AssumeRole na role principal do CodeBuild."
          exit 1
        fi

        # Exporta as credenciais para o ambiente. O Terraform as usará automaticamente.
        export AWS_ACCESS_KEY_ID=$(echo $TEMP_ROLE_JSON | jq -r .Credentials.AccessKeyId)
        export AWS_SECRET_ACCESS_KEY=$(echo $TEMP_ROLE_JSON | jq -r .Credentials.SecretAccessKey)
        export AWS_SESSION_TOKEN=$(echo $TEMP_ROLE_JSON | jq -r .Credentials.SessionToken)
        
        echo "Credenciais temporárias exportadas com sucesso."
        echo "--------------------------------------------------"
        echo "VERIFICANDO IDENTIDADE ATUAL:"
        # Este comando confirma que a nova identidade (da role dinâmica) está ativa.
        aws sts get-caller-identity
        echo "=================================================="
      # --- FIM DA NOVA FUNCIONALIDADE ---

  build:
    commands:
      # Sua lógica de manipulação de diretórios permanece intacta.
      - |
        echo "Ajustando a estrutura de diretórios dinamicamente..."
        
        PREFIX_TO_REMOVE="CloudManPro"

        for IDENTIFIER in $SECONDARY_SOURCE_IDENTIFIERS; do
          
          SOURCE_PATH_VAR_NAME="CODEBUILD_SRC_DIR_${IDENTIFIER}"
          SOURCE_PATH="${!SOURCE_PATH_VAR_NAME}"
          TARGET_NAME="${IDENTIFIER#$PREFIX_TO_REMOVE}"
          
          echo "=================================================="
          echo "Processando Identificador: ${IDENTIFIER}"
          echo "  -> Caminho de Origem: ${SOURCE_PATH}"
          echo "  -> Nome de Destino Calculado: ${TARGET_NAME}"
          
          if [ -d "${SOURCE_PATH}" ]; then
            echo "  -> Movendo '${SOURCE_PATH}' para '${TARGET_NAME}'..."
            mv "${SOURCE_PATH}" "${TARGET_NAME}"
          else
            echo "  -> AVISO: Diretório de origem '${SOURCE_PATH}' não encontrado. Pulando."
          fi
          echo "=================================================="
        done
        
        echo
        echo "--------------------------------------------------"
        echo "ESTRUTURA DE ARQUIVOS DEPOIS DO AJUSTE (VISUALIZAÇÃO):"
        ls -laR
        echo "--------------------------------------------------"
        echo

      # Os comandos do Terraform agora usarão as credenciais da role assumida.
      - |
        echo "Inicializando o Terraform com a identidade da role assumida..."
        terraform init -reconfigure

        echo "Executando o comando Terraform: ${COMMAND}"
        case ${COMMAND} in
          plan)
            terraform plan
            ;;
          apply)
            terraform plan -out=tfplan
            terraform apply -auto-approve tfplan
            ;;
          destroy)
            terraform destroy -auto-approve
            ;;
          *)
            echo "Comando '${COMMAND}' inválido. Use 'plan', 'apply' ou 'destroy'."
            exit 1
            ;;
        esac

  post_build:
    commands:
      - echo "Build para o comando '${COMMAND}' concluído."
